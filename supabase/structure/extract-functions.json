[
  {
    "schema": "public",
    "nome_funcao": "add_to_history",
    "tipo": "FUNCTION",
    "tipo_retorno": "historico_consultas",
    "nome_especifico": "19056",
    "definicao_completa": "CREATE OR REPLACE FUNCTION public.add_to_history(p_user_id character varying, p_lei character varying, p_artigo character varying, p_resultado character varying, p_tipo_crime text DEFAULT NULL::text, p_observacoes text DEFAULT NULL::text)\n RETURNS historico_consultas\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_new_record historico_consultas;\r\nBEGIN\r\n  INSERT INTO historico_consultas (user_id, lei, artigo, resultado, tipo_crime, observacoes)\r\n  VALUES (p_user_id, p_lei, p_artigo, p_resultado, p_tipo_crime, p_observacoes)\r\n  RETURNING * INTO v_new_record;\r\n  \r\n  RETURN v_new_record;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_funcao": "get_dashboard_stats",
    "tipo": "FUNCTION",
    "tipo_retorno": "TABLE(total_searches bigint, total_users bigint, total_errors bigint, inelegiveis bigint, elegiveis bigint)",
    "nome_especifico": "19089",
    "definicao_completa": "CREATE OR REPLACE FUNCTION public.get_dashboard_stats()\n RETURNS TABLE(total_searches bigint, total_users bigint, total_errors bigint, inelegiveis bigint, elegiveis bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    COUNT(*) FILTER (WHERE type = 'search')::BIGINT as total_searches,\r\n    COUNT(DISTINCT user_id)::BIGINT as total_users,\r\n    COUNT(*) FILTER (WHERE type = 'error')::BIGINT as total_errors,\r\n    COUNT(*) FILTER (WHERE resultado = 'inelegivel')::BIGINT as inelegiveis,\r\n    COUNT(*) FILTER (WHERE resultado = 'elegivel')::BIGINT as elegiveis\r\n  FROM analytics_events;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_funcao": "get_user_history",
    "tipo": "FUNCTION",
    "tipo_retorno": "SETOF historico_consultas",
    "nome_especifico": "19055",
    "definicao_completa": "CREATE OR REPLACE FUNCTION public.get_user_history(p_user_id character varying, p_limit integer DEFAULT 50)\n RETURNS SETOF historico_consultas\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT *\r\n  FROM historico_consultas\r\n  WHERE user_id = p_user_id\r\n  ORDER BY timestamp DESC\r\n  LIMIT p_limit;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_funcao": "get_user_stats",
    "tipo": "FUNCTION",
    "tipo_retorno": "TABLE(total bigint, inelegiveis bigint, elegiveis bigint, nao_consta bigint, primeira_consulta timestamp with time zone, ultima_consulta timestamp with time zone)",
    "nome_especifico": "19057",
    "definicao_completa": "CREATE OR REPLACE FUNCTION public.get_user_stats(p_user_id character varying)\n RETURNS TABLE(total bigint, inelegiveis bigint, elegiveis bigint, nao_consta bigint, primeira_consulta timestamp with time zone, ultima_consulta timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    COUNT(*)::BIGINT as total,\r\n    COUNT(*) FILTER (WHERE resultado = 'inelegivel')::BIGINT as inelegiveis,\r\n    COUNT(*) FILTER (WHERE resultado = 'elegivel')::BIGINT as elegiveis,\r\n    COUNT(*) FILTER (WHERE resultado = 'nao_consta')::BIGINT as nao_consta,\r\n    MIN(timestamp) as primeira_consulta,\r\n    MAX(timestamp) as ultima_consulta\r\n  FROM historico_consultas\r\n  WHERE user_id = p_user_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_funcao": "insert_analytics_event",
    "tipo": "FUNCTION",
    "tipo_retorno": "analytics_events",
    "nome_especifico": "19088",
    "definicao_completa": "CREATE OR REPLACE FUNCTION public.insert_analytics_event(p_type character varying, p_user_id character varying, p_lei character varying DEFAULT NULL::character varying, p_artigo character varying DEFAULT NULL::character varying, p_resultado character varying DEFAULT NULL::character varying, p_tem_excecao boolean DEFAULT NULL::boolean, p_tempo_resposta integer DEFAULT NULL::integer, p_browser text DEFAULT NULL::text, p_version character varying DEFAULT NULL::character varying, p_data jsonb DEFAULT NULL::jsonb)\n RETURNS analytics_events\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_new_record analytics_events;\r\nBEGIN\r\n  INSERT INTO analytics_events (\r\n    type, user_id, lei, artigo, resultado, \r\n    tem_excecao, tempo_resposta, browser, version, data\r\n  )\r\n  VALUES (\r\n    p_type, p_user_id, p_lei, p_artigo, p_resultado,\r\n    p_tem_excecao, p_tempo_resposta, p_browser, p_version, p_data\r\n  )\r\n  RETURNING * INTO v_new_record;\r\n  \r\n  RETURN v_new_record;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "nome_funcao": "verificar_elegibilidade",
    "tipo": "FUNCTION",
    "tipo_retorno": "TABLE(resultado character varying, tipo_crime text, observacoes text, mensagem text, item_alinea_e character varying, excecoes_artigo text)",
    "nome_especifico": "20354",
    "definicao_completa": "CREATE OR REPLACE FUNCTION public.verificar_elegibilidade(p_codigo_norma character varying, p_artigo character varying, p_paragrafo character varying DEFAULT NULL::character varying, p_inciso character varying DEFAULT NULL::character varying, p_alinea character varying DEFAULT NULL::character varying)\n RETURNS TABLE(resultado character varying, tipo_crime text, observacoes text, mensagem text, item_alinea_e character varying, excecoes_artigo text)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_record record;\r\n    v_excecoes_list TEXT;\r\nBEGIN\r\n    -- 1. Buscar o registro mais específico\r\n    -- REGRA CRÍTICA: Se p_paragrafo IS NULL, buscar apenas registros com paragrafo NULL ou 'caput'\r\n    -- Isso garante que buscar \"Art. 122\" sem parágrafo = buscar caput (não qualquer parágrafo)\r\n    SELECT \r\n        t.eh_excecao, t.tipo_crime, t.observacoes, t.item_alinea_e\r\n    INTO v_record\r\n    FROM public.crimes_inelegibilidade t\r\n    WHERE t.codigo = p_codigo_norma \r\n      AND t.artigo = p_artigo\r\n      AND (\r\n          -- Se parágrafo especificado: buscar exatamente esse parágrafo\r\n          (p_paragrafo IS NOT NULL AND t.paragrafo = p_paragrafo)\r\n          OR\r\n          -- Se parágrafo NÃO especificado: buscar o caput (paragrafo NULL)\r\n          (p_paragrafo IS NULL AND t.paragrafo IS NULL)\r\n      )\r\n      AND (p_inciso IS NULL OR t.inciso = p_inciso)\r\n      AND (p_alinea IS NULL OR t.alinea = p_alinea)\r\n    ORDER BY \r\n      (t.paragrafo IS NOT DISTINCT FROM p_paragrafo) DESC,\r\n      (t.inciso IS NOT DISTINCT FROM p_inciso) DESC,\r\n      (t.alinea IS NOT DISTINCT FROM p_alinea) DESC,\r\n      t.eh_excecao ASC \r\n    LIMIT 1;\r\n\r\n    -- 2. Buscar TODAS as exceções para este artigo (para exibir no modal)\r\n    SELECT string_agg(\r\n        CASE \r\n            WHEN t2.paragrafo IS NOT NULL AND t2.paragrafo != '' THEN \r\n                CASE \r\n                    WHEN t2.paragrafo = 'unico' THEN 'Parágrafo único'\r\n                    ELSE 'Parágrafo ' || t2.paragrafo \r\n                END\r\n            WHEN t2.inciso IS NOT NULL THEN 'Inciso ' || t2.inciso \r\n            WHEN t2.alinea IS NOT NULL THEN 'Alínea ' || t2.alinea \r\n            ELSE 'Caput'\r\n        END || COALESCE(' (' || t2.observacoes || ')', ''), \r\n        '; '\r\n    ) INTO v_excecoes_list\r\n    FROM public.crimes_inelegibilidade t2\r\n    WHERE t2.codigo = p_codigo_norma \r\n      AND t2.artigo = p_artigo \r\n      AND t2.eh_excecao = TRUE;\r\n\r\n    -- 3. Se não encontrou registro, retornar NAO_CONSTA\r\n    IF v_record IS NULL THEN\r\n        RETURN QUERY SELECT \r\n            'NAO_CONSTA'::VARCHAR, \r\n            NULL::TEXT, \r\n            NULL::TEXT, \r\n            'Artigo não mapeado como impeditivo.'::TEXT,\r\n            NULL::VARCHAR,\r\n            NULL::TEXT;\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- 4. Retornar resultado estruturado\r\n    RETURN QUERY \r\n    SELECT \r\n      (CASE WHEN v_record.eh_excecao THEN 'ELEGIVEL' ELSE 'INELEGIVEL' END)::VARCHAR, \r\n      v_record.tipo_crime::TEXT, \r\n      v_record.observacoes::TEXT, \r\n      ('Artigo consta na tabela de inelegibilidade (Item ' || COALESCE(v_record.item_alinea_e, '?') || ' da alínea \"e\")')::TEXT,\r\n      v_record.item_alinea_e::VARCHAR,\r\n      v_excecoes_list::TEXT;\r\nEND;\r\n$function$\n"
  }
]